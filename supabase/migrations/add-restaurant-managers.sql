-- Restaurant Managers: Let restaurant owners manage their specials and dishes
-- via invite links generated by admins.

-- ============================================
-- TABLES
-- ============================================

-- Restaurant managers table
CREATE TABLE IF NOT EXISTS restaurant_managers (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  restaurant_id UUID NOT NULL REFERENCES restaurants(id) ON DELETE CASCADE,
  role TEXT NOT NULL DEFAULT 'manager',
  invited_at TIMESTAMPTZ DEFAULT NOW(),
  accepted_at TIMESTAMPTZ,
  created_by UUID REFERENCES auth.users(id),
  UNIQUE(user_id, restaurant_id)
);

CREATE INDEX IF NOT EXISTS idx_restaurant_managers_user ON restaurant_managers(user_id);
CREATE INDEX IF NOT EXISTS idx_restaurant_managers_restaurant ON restaurant_managers(restaurant_id);

-- Restaurant invites table
CREATE TABLE IF NOT EXISTS restaurant_invites (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  token TEXT UNIQUE NOT NULL DEFAULT encode(gen_random_bytes(24), 'hex'),
  restaurant_id UUID NOT NULL REFERENCES restaurants(id) ON DELETE CASCADE,
  created_by UUID NOT NULL REFERENCES auth.users(id),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  expires_at TIMESTAMPTZ DEFAULT NOW() + INTERVAL '7 days',
  used_by UUID REFERENCES auth.users(id),
  used_at TIMESTAMPTZ
);

-- ============================================
-- FUNCTIONS
-- ============================================

-- Check if current user is an accepted manager for a given restaurant
CREATE OR REPLACE FUNCTION is_restaurant_manager(p_restaurant_id UUID)
RETURNS BOOLEAN AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM restaurant_managers
    WHERE user_id = auth.uid()
      AND restaurant_id = p_restaurant_id
      AND accepted_at IS NOT NULL
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER STABLE;

-- Get invite details (public preview, no auth required)
CREATE OR REPLACE FUNCTION get_invite_details(p_token TEXT)
RETURNS JSON AS $$
DECLARE
  v_invite RECORD;
BEGIN
  SELECT ri.*, r.name AS restaurant_name
  INTO v_invite
  FROM restaurant_invites ri
  JOIN restaurants r ON r.id = ri.restaurant_id
  WHERE ri.token = p_token;

  IF NOT FOUND THEN
    RETURN json_build_object('valid', false, 'error', 'Invite not found');
  END IF;

  IF v_invite.used_by IS NOT NULL THEN
    RETURN json_build_object('valid', false, 'error', 'Invite already used');
  END IF;

  IF v_invite.expires_at < NOW() THEN
    RETURN json_build_object('valid', false, 'error', 'Invite has expired');
  END IF;

  RETURN json_build_object(
    'valid', true,
    'restaurant_name', v_invite.restaurant_name,
    'restaurant_id', v_invite.restaurant_id,
    'expires_at', v_invite.expires_at
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Accept a restaurant invite (atomic operation)
CREATE OR REPLACE FUNCTION accept_restaurant_invite(p_token TEXT)
RETURNS JSON AS $$
DECLARE
  v_invite RECORD;
  v_user_id UUID;
BEGIN
  v_user_id := auth.uid();

  IF v_user_id IS NULL THEN
    RETURN json_build_object('success', false, 'error', 'Not authenticated');
  END IF;

  -- Lock the invite row to prevent race conditions
  SELECT ri.*, r.name AS restaurant_name
  INTO v_invite
  FROM restaurant_invites ri
  JOIN restaurants r ON r.id = ri.restaurant_id
  WHERE ri.token = p_token
  FOR UPDATE OF ri;

  IF NOT FOUND THEN
    RETURN json_build_object('success', false, 'error', 'Invite not found');
  END IF;

  IF v_invite.used_by IS NOT NULL THEN
    RETURN json_build_object('success', false, 'error', 'Invite already used');
  END IF;

  IF v_invite.expires_at < NOW() THEN
    RETURN json_build_object('success', false, 'error', 'Invite has expired');
  END IF;

  -- Create manager row (ON CONFLICT handles re-invites)
  INSERT INTO restaurant_managers (user_id, restaurant_id, role, accepted_at, created_by)
  VALUES (v_user_id, v_invite.restaurant_id, 'manager', NOW(), v_invite.created_by)
  ON CONFLICT (user_id, restaurant_id) DO UPDATE SET accepted_at = NOW();

  -- Mark invite as used
  UPDATE restaurant_invites
  SET used_by = v_user_id, used_at = NOW()
  WHERE id = v_invite.id;

  RETURN json_build_object(
    'success', true,
    'restaurant_id', v_invite.restaurant_id,
    'restaurant_name', v_invite.restaurant_name
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================
-- ROW LEVEL SECURITY
-- ============================================

ALTER TABLE restaurant_managers ENABLE ROW LEVEL SECURITY;
ALTER TABLE restaurant_invites ENABLE ROW LEVEL SECURITY;

-- restaurant_managers: Admins read all, managers read own rows
CREATE POLICY "Admins read all managers"
  ON restaurant_managers FOR SELECT
  USING (is_admin());

CREATE POLICY "Managers read own rows"
  ON restaurant_managers FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Admins manage all managers"
  ON restaurant_managers FOR ALL
  USING (is_admin());

-- restaurant_invites: Admins manage all
-- Public invite preview is handled by get_invite_details() which is SECURITY DEFINER
-- so no public SELECT policy is needed (prevents token enumeration)
CREATE POLICY "Admins manage invites"
  ON restaurant_invites FOR ALL
  USING (is_admin());

-- ============================================
-- UPDATE EXISTING RLS POLICIES
-- ============================================

-- Dishes: Widen INSERT/UPDATE to include restaurant managers
-- (DELETE stays admin-only as defined in existing admin RLS)
DROP POLICY IF EXISTS "Admin insert dishes" ON dishes;
CREATE POLICY "Admin or manager insert dishes"
  ON dishes FOR INSERT
  WITH CHECK (is_admin() OR is_restaurant_manager(restaurant_id));

DROP POLICY IF EXISTS "Admin update dishes" ON dishes;
CREATE POLICY "Admin or manager update dishes"
  ON dishes FOR UPDATE
  USING (is_admin() OR is_restaurant_manager(restaurant_id));

-- Specials: Scope INSERT/UPDATE/DELETE to admins and restaurant managers
DROP POLICY IF EXISTS "Authenticated users can create specials" ON specials;
CREATE POLICY "Admin or manager insert specials"
  ON specials FOR INSERT
  WITH CHECK (is_admin() OR is_restaurant_manager(restaurant_id));

DROP POLICY IF EXISTS "Authenticated users can update specials" ON specials;
CREATE POLICY "Admin or manager update specials"
  ON specials FOR UPDATE
  USING (is_admin() OR is_restaurant_manager(restaurant_id));

DROP POLICY IF EXISTS "Authenticated users can delete specials" ON specials;
CREATE POLICY "Admin or manager delete specials"
  ON specials FOR DELETE
  USING (is_admin() OR is_restaurant_manager(restaurant_id));

-- Managers can see inactive specials for their own restaurant
DROP POLICY IF EXISTS "Public read active specials" ON specials;
CREATE POLICY "Read specials"
  ON specials FOR SELECT
  USING (
    is_active = true
    OR is_admin()
    OR is_restaurant_manager(restaurant_id)
  );
